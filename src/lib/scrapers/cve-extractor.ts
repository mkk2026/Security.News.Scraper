import crypto from 'crypto'

export interface ExtractedCVE {
  cveId: string
  description?: string
  cvssScore?: number
  severity?: string
  affectedSoftware?: string
}

export interface ArticleWithCVEs {
  articleText: string
  cves: ExtractedCVE[]
  severityScore: number
  severityLevel: string
}

/**
 * Extract CVE IDs from text using regex pattern
 * CVE format: CVE-YYYY-NNNN (where NNNN is 4+ digits)
 */
export function extractCVEs(text: string): string[] {
  if (!text) return []

  const cveRegex = /CVE-\d{4}-\d{4,}/gi
  const matches = text.match(cveRegex) || []

  // Deduplicate and normalize
  const uniqueCVEs = Array.from(new Set(matches.map(cve => cve.toUpperCase())))

  return uniqueCVEs
}

/**
 * Calculate severity score based on keywords and content analysis
 */
export function calculateSeverityScore(text: string, cves: ExtractedCVE[]): { score: number; level: string } {
  let score = 0

  // Base score from CVSS scores
  if (cves.length > 0) {
    const maxCvss = Math.max(...cves.map(c => c.cvssScore || 0))
    score = maxCvss
  }

  // Keyword-based scoring
  const criticalKeywords = [
    'critical', 'remote code execution', 'rce', 'zero-day', '0-day',
    'unauthenticated', 'bypass', 'privilege escalation', 'privilege escalation',
    'arbitrary code', 'complete compromise', 'takeover'
  ]

  const highKeywords = [
    'vulnerability', 'exploit', 'security', 'patch', 'advisory',
    'cve', 'attack', 'malicious', 'injection', 'xss', 'csrf',
    'sql injection', 'buffer overflow', 'deserialization'
  ]

  const mediumKeywords = [
    'bug', 'issue', 'fix', 'update', 'release', 'notice',
    'warning', 'recommendation', 'best practice'
  ]

  const lowerText = text.toLowerCase()

  // Score based on keywords
  for (const keyword of criticalKeywords) {
    if (lowerText.includes(keyword)) {
      score += 2
    }
  }

  for (const keyword of highKeywords) {
    if (lowerText.includes(keyword)) {
      score += 1
    }
  }

  for (const keyword of mediumKeywords) {
    if (lowerText.includes(keyword)) {
      score += 0.5
    }
  }

  // Boost score based on number of CVEs
  score += cves.length * 0.5

  // Cap score at 10
  score = Math.min(score, 10)

  // Determine severity level
  let level = 'LOW'
  if (score >= 9.0) level = 'CRITICAL'
  else if (score >= 7.0) level = 'HIGH'
  else if (score >= 4.0) level = 'MEDIUM'

  return { score, level }
}

const SOFTWARE_MATCHERS = [
  {
    pattern: /Windows\s+(10|11|Server\s+\d{4})/gi,
    keywords: ['windows'],
  },
  {
    pattern: /Microsoft\s+(Office|SharePoint|Exchange|Azure|SQL Server)/gi,
    keywords: ['microsoft'],
  },
  {
    pattern: /(Apache|Nginx|OpenSSL|OpenSSH|Linux|Ubuntu|Debian|CentOS|Red Hat)/gi,
    keywords: ['apache', 'nginx', 'openssl', 'openssh', 'linux', 'ubuntu', 'debian', 'centos', 'red hat'],
  },
  {
    pattern: /(Adobe\s+(Reader|Flash|Photoshop))/gi,
    keywords: ['adobe'],
  },
  {
    pattern: /(Google\s+(Chrome|Android))/gi,
    keywords: ['google'],
  },
  {
    pattern: /(Apple\s+(macOS|iOS|Safari))/gi,
    keywords: ['apple'],
  },
  {
    pattern: /(Mozilla\s+Firefox)/gi,
    keywords: ['mozilla'],
  },
  {
    pattern: /(Cisco|Juniper|Fortinet|Palo Alto)/gi,
    keywords: ['cisco', 'juniper', 'fortinet', 'palo alto'],
  },
  {
    pattern: /(WordPress|Drupal|Joomla|Magento)/gi,
    keywords: ['wordpress', 'drupal', 'joomla', 'magento'],
  },
  {
    pattern: /(Docker|Kubernetes|Jenkins|GitLab|GitHub)/gi,
    keywords: ['docker', 'kubernetes', 'jenkins', 'gitlab', 'github'],
  },
  {
    pattern: /([A-Za-z]+)\s+(Enterprise|Server|Platform|Framework|Library)/gi,
    keywords: ['enterprise', 'server', 'platform', 'framework', 'library'],
  },
];

/**
 * Extract affected software names from text
 */
export function extractAffectedSoftware(text: string): string[] {
  if (!text) return [];

  const lowerText = text.toLowerCase();
  const softwareSet = new Set<string>();

  for (const matcher of SOFTWARE_MATCHERS) {
    let shouldRun = false;
    // Fast path: check if any required keyword exists using string search (much faster than regex)
    for (const keyword of matcher.keywords) {
      if (lowerText.includes(keyword)) {
        shouldRun = true;
        break;
      }
    }

    if (shouldRun) {
      const matches = text.match(matcher.pattern) || [];
      for (const match of matches) {
        softwareSet.add(match.trim());
      }
    }
  }

  return Array.from(softwareSet);
}

/**
 * Parse and analyze article content for CVEs and severity
 */
export function analyzeArticleContent(
  title: string,
  summary: string | undefined,
  content: string | undefined
): ArticleWithCVEs {
  const fullText = `${title} ${summary || ''} ${content || ''}`

  // Extract CVE IDs
  const cveIds = extractCVEs(fullText)

  // Create CVE objects with extracted information
  const cves: ExtractedCVE[] = cveIds.map(cveId => {
    const cve: ExtractedCVE = {
      cveId,
    }

    // Try to extract CVSS score from text (pattern: CVSS: 9.8 or CVSS v3.1: 9.8)
    const cvssMatch = fullText.match(new RegExp(`${cveId}[^.]*?CVSS[^:]*:\\s*(\\d+\\.\\d+)`, 'i'))
    if (cvssMatch) {
      cve.cvssScore = parseFloat(cvssMatch[1])
    }

    return cve
  })

  // Extract affected software
  const affectedSoftware = extractAffectedSoftware(fullText)

  // Calculate severity score
  const { score, level } = calculateSeverityScore(fullText, cves)

  return {
    articleText: fullText,
    cves,
    severityScore: score,
    severityLevel: level,
  }
}

/**
 * Generate content hash for duplicate detection
 */
export function generateContentHash(content: string): string {
  // Normalize content: lowercase, remove extra whitespace
  const normalized = content
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .trim()

  return crypto.createHash('sha256').update(normalized).digest('hex')
}

/**
 * Detect if two articles are duplicates based on content similarity
 */
export function isDuplicateArticle(
  existingTitle: string,
  existingSummary: string | undefined,
  newTitle: string,
  newSummary: string | undefined,
  threshold: number = 0.8
): boolean {
  const combinedExisting = `${existingTitle} ${existingSummary || ''}`
  const combinedNew = `${newTitle} ${newSummary || ''}`

  const hashExisting = generateContentHash(combinedExisting)
  const hashNew = generateContentHash(combinedNew)

  // Direct hash match (exact duplicate)
  if (hashExisting === hashNew) {
    return true
  }

  // Simple similarity check (can be enhanced with more sophisticated algorithms)
  const similarity = calculateJaccardSimilarity(combinedExisting, combinedNew)
  return similarity >= threshold
}

/**
 * Calculate Jaccard similarity between two strings
 */
function calculateJaccardSimilarity(str1: string, str2: string): number {
  const set1 = new Set(str1.toLowerCase().split(/\s+/))
  const set2 = new Set(str2.toLowerCase().split(/\s+/))

  const intersection = new Set([...set1].filter(x => set2.has(x)))
  const union = new Set([...set1, ...set2])

  if (union.size === 0) return 0

  return intersection.size / union.size
}

/**
 * Extract CVE metadata from article text (description, severity, etc.)
 */
export function extractCVEMetadata(cveId: string, text: string): Partial<ExtractedCVE> {
  const metadata: Partial<ExtractedCVE> = {
    cveId,
  }

  // Look for description near CVE mention
  const cveRegex = new RegExp(`${cveId}[^.]*\\.`, 'gi')
  const cveMatches = text.match(cveRegex)

  if (cveMatches && cveMatches.length > 0) {
    // Take the first meaningful context
    metadata.description = cveMatches[0].substring(0, 200)
  }

  // Extract CVSS score
  const cvssMatch = text.match(new RegExp(`${cveId}[^.]*?CVSS[^:]*:\\s*(\\d+\\.\\d+)`, 'i'))
  if (cvssMatch) {
    metadata.cvssScore = parseFloat(cvssMatch[1])

    // Determine severity based on CVSS
    if (metadata.cvssScore >= 9.0) {
      metadata.severity = 'CRITICAL'
    } else if (metadata.cvssScore >= 7.0) {
      metadata.severity = 'HIGH'
    } else if (metadata.cvssScore >= 4.0) {
      metadata.severity = 'MEDIUM'
    } else {
      metadata.severity = 'LOW'
    }
  }

  return metadata
}
