import crypto from 'crypto'

export interface ExtractedCVE {
  cveId: string
  description?: string
  cvssScore?: number
  severity?: string
  affectedSoftware?: string
}

export interface ArticleWithCVEs {
  articleText: string
  cves: ExtractedCVE[]
  severityScore: number
  severityLevel: string
}

/**
 * Extract CVE IDs from text using regex pattern
 * CVE format: CVE-YYYY-NNNN (where NNNN is 4+ digits)
 */
export function extractCVEs(text: string): string[] {
  if (!text) return []

  const cveRegex = /CVE-\d{4}-\d{4,}/gi
  const matches = text.match(cveRegex) || []

  // Deduplicate and normalize
  const uniqueCVEs = Array.from(new Set(matches.map(cve => cve.toUpperCase())))

  return uniqueCVEs
}

/**
 * Calculate severity score based on keywords and content analysis
 */
export function calculateSeverityScore(text: string, cves: ExtractedCVE[]): { score: number; level: string } {
  let score = 0

  // Base score from CVSS scores
  if (cves.length > 0) {
    const maxCvss = Math.max(...cves.map(c => c.cvssScore || 0))
    score = maxCvss
  }

  // Keyword-based scoring
  const criticalKeywords = [
    'critical', 'remote code execution', 'rce', 'zero-day', '0-day',
    'unauthenticated', 'bypass', 'privilege escalation', 'privilege escalation',
    'arbitrary code', 'complete compromise', 'takeover'
  ]

  const highKeywords = [
    'vulnerability', 'exploit', 'security', 'patch', 'advisory',
    'cve', 'attack', 'malicious', 'injection', 'xss', 'csrf',
    'sql injection', 'buffer overflow', 'deserialization'
  ]

  const mediumKeywords = [
    'bug', 'issue', 'fix', 'update', 'release', 'notice',
    'warning', 'recommendation', 'best practice'
  ]

  const lowerText = text.toLowerCase()

  // Score based on keywords
  for (const keyword of criticalKeywords) {
    if (lowerText.includes(keyword)) {
      score += 2
    }
  }

  for (const keyword of highKeywords) {
    if (lowerText.includes(keyword)) {
      score += 1
    }
  }

  for (const keyword of mediumKeywords) {
    if (lowerText.includes(keyword)) {
      score += 0.5
    }
  }

  // Boost score based on number of CVEs
  score += cves.length * 0.5

  // Cap score at 10
  score = Math.min(score, 10)

  // Determine severity level
  let level = 'LOW'
  if (score >= 9.0) level = 'CRITICAL'
  else if (score >= 7.0) level = 'HIGH'
  else if (score >= 4.0) level = 'MEDIUM'

  return { score, level }
}

/**
 * Extract affected software names from text
 */
export function extractAffectedSoftware(text: string): string[] {
  if (!text) return []

  const softwarePatterns = [
    // Common software and platforms
    /Windows\s+(10|11|Server\s+\d{4})/gi,
    /Microsoft\s+(Office|SharePoint|Exchange|Azure|SQL Server)/gi,
    /(Apache|Nginx|OpenSSL|OpenSSH|Linux|Ubuntu|Debian|CentOS|Red Hat)/gi,
    /(Adobe\s+(Reader|Flash|Photoshop))/gi,
    /(Google\s+(Chrome|Android))/gi,
    /(Apple\s+(macOS|iOS|Safari))/gi,
    /(Mozilla\s+Firefox)/gi,
    /(Cisco|Juniper|Fortinet|Palo Alto)/gi,
    /(WordPress|Drupal|Joomla|Magento)/gi,
    /(Docker|Kubernetes|Jenkins|GitLab|GitHub)/gi,
    /([A-Za-z]+)\s+(Enterprise|Server|Platform|Framework|Library)/gi,
  ]

  const softwareSet = new Set<string>()

  for (const pattern of softwarePatterns) {
    const matches = text.match(pattern) || []
    matches.forEach(match => softwareSet.add(match.trim()))
  }

  return Array.from(softwareSet)
}

/**
 * Parse and analyze article content for CVEs and severity
 */
export function analyzeArticleContent(
  title: string,
  summary: string | undefined,
  content: string | undefined
): ArticleWithCVEs {
  const fullText = `${title} ${summary || ''} ${content || ''}`

  // Extract CVE IDs
  const cveIds = extractCVEs(fullText)

  // Create CVE objects with extracted information
  // Optimize: Prepare lowercase text once for case-insensitive searching
  const lowerText = fullText.toLowerCase()

  const cves: ExtractedCVE[] = cveIds.map(cveId => {
    const cve: ExtractedCVE = {
      cveId,
    }

    // Performance optimization: Avoid creating N regexes and scanning full text N times
    // Find ALL occurrences of the CVE in the text (case-insensitive)
    const lowerCveId = cveId.toLowerCase()
    let cvePos = lowerText.indexOf(lowerCveId)

    while (cvePos !== -1) {
      // Look for CVSS score in the vicinity (same sentence / limited window)
      // Limit scan to 500 chars to prevent DoS on malicious inputs with no periods
      const scanLimit = 500

      // Find "cvss" keyword
      const cvssPos = lowerText.indexOf('cvss', cvePos)

      if (cvssPos !== -1 && cvssPos < cvePos + scanLimit) {
        // Check if there is a dot between CVE and CVSS
        // The original logic `[^.]*?` ensured no dots between CVE and CVSS.
        const dotPos = lowerText.indexOf('.', cvePos)

        // If no dot found, or dot is AFTER "cvss", then it's a match candidate
        if (dotPos === -1 || dotPos > cvssPos) {
          // Extract a snippet around CVSS to capture the score
          // "cvss: 9.8" length is ~10 chars. 50 chars should be plenty.
          const snippet = lowerText.substring(cvssPos, cvssPos + 50)

          const cvssMatch = snippet.match(/cvss[^:]*:\s*(\d+\.\d+)/)
          if (cvssMatch) {
            cve.cvssScore = parseFloat(cvssMatch[1])
            break // Found a score for this CVE, stop searching
          }
        }
      }

      // Find next occurrence
      cvePos = lowerText.indexOf(lowerCveId, cvePos + 1)
    }

    return cve
  })

  // Extract affected software
  const affectedSoftware = extractAffectedSoftware(fullText)

  // Calculate severity score
  const { score, level } = calculateSeverityScore(fullText, cves)

  return {
    articleText: fullText,
    cves,
    severityScore: score,
    severityLevel: level,
  }
}

/**
 * Generate content hash for duplicate detection
 */
export function generateContentHash(content: string): string {
  // Normalize content: lowercase, remove extra whitespace
  const normalized = content
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .trim()

  return crypto.createHash('sha256').update(normalized).digest('hex')
}

/**
 * Detect if two articles are duplicates based on content similarity
 */
export function isDuplicateArticle(
  existingTitle: string,
  existingSummary: string | undefined,
  newTitle: string,
  newSummary: string | undefined,
  threshold: number = 0.8
): boolean {
  const combinedExisting = `${existingTitle} ${existingSummary || ''}`
  const combinedNew = `${newTitle} ${newSummary || ''}`

  const hashExisting = generateContentHash(combinedExisting)
  const hashNew = generateContentHash(combinedNew)

  // Direct hash match (exact duplicate)
  if (hashExisting === hashNew) {
    return true
  }

  // Simple similarity check (can be enhanced with more sophisticated algorithms)
  const similarity = calculateJaccardSimilarity(combinedExisting, combinedNew)
  return similarity >= threshold
}

/**
 * Calculate Jaccard similarity between two strings
 */
function calculateJaccardSimilarity(str1: string, str2: string): number {
  const set1 = new Set(str1.toLowerCase().split(/\s+/))
  const set2 = new Set(str2.toLowerCase().split(/\s+/))

  const intersection = new Set([...set1].filter(x => set2.has(x)))
  const union = new Set([...set1, ...set2])

  if (union.size === 0) return 0

  return intersection.size / union.size
}

